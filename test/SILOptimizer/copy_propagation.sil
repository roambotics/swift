// RUN: %target-sil-opt -copy-propagation -canonical-ossa-rewrite-borrows -enable-sil-opaque-values -enable-sil-verify-all %s | %FileCheck %s --check-prefixes=CHECK,CHECK-OPT
// RUN: %target-sil-opt -mandatory-copy-propagation -canonical-ossa-rewrite-borrows -enable-sil-opaque-values -enable-sil-verify-all %s | %FileCheck %s --check-prefixes=CHECK,CHECK-DEBUG
// RUN: %target-sil-opt -copy-propagation -canonical-ossa-rewrite-borrows -enable-sil-opaque-values -debug-only=copy-propagation %s -o /dev/null 2>&1 | %FileCheck %s --check-prefix=CHECK-TRACE

// REQUIRES: asserts

sil_stage canonical

import Builtin
import Swift

sil [ossa] @getOwnedC : $@convention(thin) () -> (@owned C)
sil [ossa] @takeOwned : $@convention(thin) <T> (@in T) -> ()
sil [ossa] @takeMultipleOwned : $@convention(thin) <T> (@in T, @in T) -> ()
sil [ossa] @takeGuaranteed : $@convention(thin) <T> (@in_guaranteed T) -> ()
sil [ossa] @takeGuaranteedAndOwnedArg : $@convention(thin) <T> (@in_guaranteed T, @in T) -> ()

class B { }

class C {
  var a: Int64
}
sil [ossa] @takeOwnedC : $@convention(thin) (@owned C) -> ()
sil [ossa] @takeOwnedCTwice : $@convention(thin) (@owned C, @owned C) -> ()
sil [ossa] @takeGuaranteedC : $@convention(thin) (@guaranteed C) -> ()

struct NativeObjectPair {
  var obj1 : Builtin.NativeObject
  var obj2 : Builtin.NativeObject
}

// Once Mem2Reg supports ownership, it will leave behind extra copies as
// seen in the SIL test below for simple assignment:
// public func testVarAssign<T>(_ t: T) -> T {
//  var u = t
//  return u
// }
// CopyPropagation should leave behind a single copy and no destroys.
//
// CHECK-LABEL: sil [ossa] @testVarAssign : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK-NOT: destroy
// CHECK:   [[CPY:%.*]] = copy_value %0 : $T
// CHECK_CHECK-NOT: destroy
// CHECK_CHECK:   return [[CPY]] : $T
// CHECK-LABEL: } // end sil function 'testVarAssign'
sil [ossa] @testVarAssign : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
bb0(%0 : @guaranteed $T):
  %1 = copy_value %0 : $T
  %2 = copy_value %1 : $T
  destroy_value %1 : $T
  return %2 : $T
}

// CHECK-LABEL: sil [ossa] @multiReturnValue : $@convention(thin) <T> (@in_guaranteed T) -> (@out T, @out T) {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK-NOT: destroy
// CHECK:   [[CPY1:%.*]] = copy_value %0 : $T
// CHECK_CHECK-NOT: destroy
// CHECK_CHECK:   [[CPY2:%.*]] = copy_value %0 : $T
// CHECK_CHECK-NOT: destroy
// CHECK_CHECK:   [[R:%.*]] = tuple ([[CPY1]] : $T, [[CPY2]] : $T)
// CHECK_CHECK-NOT: destroy
// CHECK_CHECK:   return [[R]] : $(T, T)
// CHECK-LABEL: } // end sil function 'multiReturnValue'
sil [ossa] @multiReturnValue : $@convention(thin) <T> (@in_guaranteed T) -> (@out T, @out T) {
bb0(%0 : @guaranteed $T):
  %1 = copy_value %0 : $T
  %2 = copy_value %1 : $T
  %3 = copy_value %1 : $T
  %4 = tuple (%2 : $T, %3 : $T)
  destroy_value %1 : $T
  return %4 : $(T, T)
}

// CHECK-LABEL: sil [ossa] @multiCallResult : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK_CHECK-NEXT: // function_ref multiReturnValue
// CHECK_CHECK-NEXT: [[F:%.*]] = function_ref @multiReturnValue : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK_CHECK-NEXT: [[CALL:%.*]] = apply [[F]]<T>(%0) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
// CHECK_CHECK-NEXT: ([[D1:%.*]], [[D2:%.*]]) = destructure_tuple [[CALL]] : $(T, T)
// CHECK_CHECK-NEXT: destroy_value [[D2]] : $T
// CHECK_CHECK-NEXT: return [[D1]] : $T
// CHECK-LABEL: } // end sil function 'multiCallResult'
sil [ossa] @multiCallResult : $@convention(thin) <T> (@in_guaranteed T) -> @out T {
bb0(%0 : @guaranteed $T):
  %1 = copy_value %0 : $T
  %2 = function_ref @multiReturnValue : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  %3 = apply %2<T>(%1) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> (@out τ_0_0, @out τ_0_0)
  (%4, %5) = destructure_tuple %3 : $(T, T)
  %6 = copy_value %4 : $T
  %7 = copy_value %5 : $T
  destroy_value %1 : $T
  destroy_value %4 : $T
  destroy_value %5 : $T
  destroy_value %7 : $T
  return %6 : $T
}

// CHECK-LABEL: sil [ossa] @testPhi : $@convention(thin) <T> (@in_guaranteed T, @in_guaranteed T, Bool) -> @out T {
// CHECK: bb0(%0 : @guaranteed $T, %1 : @guaranteed $T, %2 : $Bool):
// CHECK_CHECK-NEXT: struct_extract %2 : $Bool, #Bool._value
// CHECK_CHECK-NEXT: cond_br %{{.*}}, bb1, bb2
//
// CHECK: bb1:
// CHECK_CHECK-NEXT: copy_value %0 : $T
// CHECK_CHECK-NEXT: br bb3(%
//
// CHECK: bb2:
// CHECK_CHECK-NEXT: copy_value %1 : $T
// CHECK_CHECK-NEXT: br bb3(%
//
// CHECK: bb3(%
// CHECK_CHECK-NEXT: return
// CHECK-LABEL: } // end sil function 'testPhi'
sil [ossa] @testPhi : $@convention(thin) <T> (@in_guaranteed T, @in_guaranteed T, Bool) -> @out T {
bb0(%0 : @guaranteed $T, %1 : @guaranteed $T, %2 : $Bool):
  %3 = copy_value %0 : $T
  %4 = copy_value %1 : $T
  %5 = struct_extract %2 : $Bool, #Bool._value
  cond_br %5, bb1, bb2

bb1:
  %7 = copy_value %3 : $T
  br bb3(%7 : $T)

bb2:
  %9 = copy_value %4 : $T
  br bb3(%9 : $T)

bb3(%11 : @owned $T):
  destroy_value %4 : $T
  destroy_value %3 : $T
  return %11 : $T
}

// CHECK-LABEL: sil [ossa] @testConsume : $@convention(thin) <T> (@in T, @inout T) -> () {
// CHECK: bb0(%0 : @owned $T, %1 : $*T):
//
// Mandatory opt reuses the original copy for the consuming store.
// CHECK-DEBUG-NEXT:   [[STOREVAL:%.*]] = copy_value %0 : $T
//
// CHECK-NEXT:   debug_value %0 : $T
// CHECK-DEBUG-NEXT: store [[STOREVAL]] to [assign] %1 : $*T
// CHECK-OPT-NEXT:   store %0 to [assign] %1 : $*T
//
// The non-consuming use now uses the original value.
// CHECK-DEBUG-NEXT:   debug_value %0 : $T
//
// CHECK-NEXT:   debug_value_addr %1 : $*T
//
// The original destroy is deleted with optimizations enabled.
// CHECK-DEBUG-NEXT:   destroy_value %0 : $T
// CHECK-NEXT:   tuple ()
// CHECK-NEXT:   return
// CHECK-LABEL: // end sil function 'testConsume'
sil [ossa] @testConsume : $@convention(thin) <T> (@in T, @inout T) -> () {
bb0(%arg : @owned $T, %addr : $*T):
  %copy = copy_value %arg : $T
  debug_value %copy : $T
  store %copy to [assign] %addr : $*T
  debug_value %arg : $T
  debug_value_addr %addr : $*T
  destroy_value %arg : $T
  %v = tuple ()
  return %v : $()
}

// CHECK-LABEL: sil [ossa] @testDestroyEdge : $@convention(thin) <T> (@in T, Builtin.Int1) -> () {
// CHECK: bb0(%0 : @owned $T, %1 : $Builtin.Int1):
// CHECK-OPT-NEXT:   destroy_value %0 : $T
// CHECK-DEBUG-NEXT: cond_br %1, bb2, bb1
//
// CHECK: bb1:
// Debug build inserts a new destroy
// CHECK-DEBUG-NEXT: destroy_value %0 : $T
// CHECK-NEXT:     br bb3
//
// CHECK: bb2:
// The original copy is deleted in both cases.
// CHECK-DEBUG-NEXT:   debug_value %0 : $T
// CHECK-DEBUG-NEXT:   destroy_value %0 : $T
// CHECK-NEXT:   br bb3
//
// CHECK: bb3:
// The original destroy is deleted in both cases.
// CHECK-NEXT:   tuple ()
// CHECK-NEXT:   return
// CHECK-LABEL: } // end sil function 'testDestroyEdge'
sil [ossa] @testDestroyEdge : $@convention(thin) <T> (@in T, Builtin.Int1) -> () {
bb0(%arg : @owned $T, %z : $Builtin.Int1):
  cond_br %z, bb2, bb1

bb1:
  br bb3

bb2:
  debug_value %arg : $T
  %copy = copy_value %arg : $T
  destroy_value %copy : $T
  br bb3

bb3:
  destroy_value %arg : $T
  %10 = tuple ()
  return %10 : $()
}

// Test the same user instruction with both @guaranteed and @owned operands taking the same copied value.
// We need to keep the value alive to the end of the instruction.
//
// CHECK-LABEL: sil [ossa] @testGuaranteedAndOwnedArg : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : @owned $T):
// CHECK-NEXT: [[CPY:%.*]] = copy_value %0 : $T
// CHECK-NEXT: // function_ref takeGuaranteedAndOwnedArg
// CHECK-NEXT: function_ref @takeGuaranteedAndOwnedArg : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0, @in τ_0_0) -> ()
// CHECK-NEXT: apply %{{.*}}<T>(%0, [[CPY]]) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0, @in τ_0_0) -> ()
// CHECK-NEXT: destroy_value %0 : $T
// CHECK-NEXT: return %{{.*}} : $()
// CHECK-LABEL: } // end sil function 'testGuaranteedAndOwnedArg'
sil [ossa] @testGuaranteedAndOwnedArg : $@convention(thin) <T> (@in T) -> () {
bb(%0 : @owned $T):
  %copy = copy_value %0 : $T
  %f = function_ref @takeGuaranteedAndOwnedArg : $@convention(thin) <T> (@in_guaranteed T, @in T) -> ()
  %call = apply %f<T>(%0, %copy) : $@convention(thin) <T> (@in_guaranteed T, @in T) -> ()
  destroy_value %0 : $T
  return %call : $()
}

// Reuse one of the copies for the apply. Eliminate the other copy and destroy.
// Which copy is reused is unfortunately sensitive to the use list order.
//
// CHECK-TRACE-LABEL: CopyPropagation: testCopy2OperReuse
// CHECK-TRACE:  Removing   destroy_value %0 : $T
// CHECK-TRACE:  Removing   %{{.*}} = copy_value %0 : $T
// CHECK-TRACE-NOT:  Removing
//
// CHECK-LABEL: sil [ossa] @testCopy2OperReuse : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : @owned $T):
// CHECK-NEXT:  [[CP:%.*]] = copy_value %0 : $T
// CHECK-NEXT:  // function_ref takeMultipleOwned
// CHECK-NEXT:  function_ref @takeMultipleOwned : $@convention(thin) <τ_0_0> (@in τ_0_0, @in τ_0_0) -> ()
// CHECK-NEXT:  apply %{{.*}}<T>(%0, [[CP]]) : $@convention(thin) <τ_0_0> (@in τ_0_0, @in τ_0_0) -> ()
// CHECK-NEXT:  tuple ()
// CHECK-NEXT:  return
// CHECK-LABEL: } // end sil function 'testCopy2OperReuse'
sil [ossa] @testCopy2OperReuse : $@convention(thin) <T> (@in T) -> () {
bb0(%arg : @owned $T):
  %copy1 = copy_value %arg : $T
  %copy2 = copy_value %arg : $T
  %f = function_ref @takeMultipleOwned : $@convention(thin) <T> (@in T, @in T) -> ()
  %call = apply %f<T>(%copy1, %copy2) : $@convention(thin) <T> (@in T, @in T) -> ()
  destroy_value %arg : $T
  %10 = tuple ()
  return %10 : $()
}

// Reuse one copy and eliminate the other copy and destroy.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testCopy2CallReuse
// CHECK-TRACE:  Removing   destroy_value %0 : $T
// CHECK-TRACE:  Removing   %{{.*}} = copy_value %0 : $T
// CHECK-TRACE-NOT:  Removing
//
// CHECK-LABEL: sil [ossa] @testCopy2CallReuse : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : @owned $T):
// CHECK-NEXT:  [[CP:%.*]] = copy_value %0 : $T
// CHECK-NEXT:  // function_ref
// CHECK-NEXT:  function_ref
// CHECK-NEXT:  apply %{{.*}}<T>([[CP]])
// CHECK-NEXT:  apply %{{.*}}<T>(%0)
// CHECK-NEXT:  tuple
// CHECK-NEXT:  return
// CHECK-LABEL: } // end sil function 'testCopy2CallReuse'
sil [ossa] @testCopy2CallReuse : $@convention(thin) <T> (@in T) -> () {
bb0(%arg : @owned $T):
  %copy1 = copy_value %arg : $T
  %copy2 = copy_value %arg : $T
  %f = function_ref @takeOwned : $@convention(thin) <T> (@in T) -> ()
  %call1 = apply %f<T>(%copy1) : $@convention(thin) <T> (@in T) -> ()
  %call2 = apply %f<T>(%copy2) : $@convention(thin) <T> (@in T) -> ()
  destroy_value %arg : $T
  %10 = tuple ()
  return %10 : $()
}

// bb1 has a consuming instruction but is also live-out. Reuse the copy in bb1.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: liveoutConsume
// CHECK-TRACE:  Removing   destroy_value %0 : $T
// CHECK-TRACE:  Removing   %{{.*}} = copy_value %0 : $T
// CHECK-TRACE-NOT:  Removing
//
// CHECK-LABEL: sil [ossa] @liveoutConsume : $@convention(thin) <T> (@owned T, Builtin.Int1) -> () {
// CHECK: bb0(%0 : @owned $T, %1 : $Builtin.Int1):
// CHECK-NOT: copy_value
// CHECK: cond_br %1, bb2, bb1
// CHECK: bb1:
// CHECK: copy_value %0 : $T
// CHECK: apply
// CHECK: br bb3
// CHECK: bb3:
// CHECK-NOT: copy_value
// CHECK: apply
// CHECK-NOT: destroy_value
// CHECK-LABEL: } // end sil function 'liveoutConsume'
sil [ossa] @liveoutConsume : $@convention(thin) <T> (@owned T, Builtin.Int1) -> () {
bb0(%arg : @owned $T, %z : $Builtin.Int1):
  %copy1 = copy_value %arg : $T
  cond_br %z, bb2, bb1

bb1:
  %copy2 = copy_value %arg : $T
  %f1 = function_ref @takeOwned : $@convention(thin) <T> (@in T) -> ()
  %call1 = apply %f1<T>(%copy2) : $@convention(thin) <T> (@in T) -> ()
  br bb3

bb2:
  br bb3

bb3:
  %f2 = function_ref @takeOwned : $@convention(thin) <T> (@in T) -> ()
  %call2 = apply %f2<T>(%copy1) : $@convention(thin) <T> (@in T) -> ()
  destroy_value %arg : $T
  %10 = tuple ()
  return %10 : $()
}

// The LiveWithin block has a destroy, but it's before the first use.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testDestroyBeforeUse
// CHECK-TRACE:  Removing   destroy_value %1 : $T
// CHECK-TRACE:  Removing   %{{.*}} = copy_value %0 : $T
//
// CHECK-LABEL: sil [ossa] @testDestroyBeforeUse : $@convention(thin) <T> (@in T) -> () {
// CHECK: bb0(%0 : @owned $T):
// CHECK-NOT: copy_value
// CHECK-NOT: destroy_value
// CHECK: apply
// CHECK-NOT: destroy_value
// CHECK: return
// CHECK-LABEL: } // end sil function 'testDestroyBeforeUse'
sil [ossa] @testDestroyBeforeUse : $@convention(thin) <T> (@in T) -> () {
bb0(%arg : @owned $T):
  %copy = copy_value %arg : $T
  destroy_value %copy : $T
  %f = function_ref @takeOwned : $@convention(thin) <T> (@in T) -> ()
  %call2 = apply %f<T>(%arg) : $@convention(thin) <T> (@in T) -> ()
  %10 = tuple ()
  return %10 : $()
}

// The LiveWithin block has a destroy, but it's after an unrelated call.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testDestroyAfterCall
// CHECK-TRACE-NOT: Removing
//
// CHECK-LABEL: sil [ossa] @testDestroyAfterCall : $@convention(thin) <T> (@in T, @in T) -> () {
// CHECK: bb0(%0 : @owned $T, %1 : @owned $T):
// CHECK: apply %{{.*}}<T>(%0) : $@convention(thin) <τ_0_0> (@in τ_0_0) -> ()
// CHECK: destroy_value %1 : $T
// CHECK-LABEL: } // end sil function 'testDestroyAfterCall'
sil [ossa] @testDestroyAfterCall : $@convention(thin) <T> (@in T, @in T) -> () {
bb0(%arg1 : @owned $T, %arg2 : @owned $T):
  %f = function_ref @takeOwned : $@convention(thin) <T> (@in T) -> ()
  %call = apply %f<T>(%arg1) : $@convention(thin) <T> (@in T) -> ()
  destroy_value %arg2 : $T
  %10 = tuple ()
  return %10 : $()
}

// A copy may have multiple uses
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testSharedCopy
// CHECK-TRACE:  Removing   destroy_value %0 : $T
// CHECK-TRACE:  Removing   %1 = copy_value %0 : $T
// CHECK-TRACE-NOT: Removing
//
// CHECK-LABEL: sil [ossa] @testSharedCopy : $@convention(thin) <T> (@in T) -> () {
// CHECK-NOT: copy_value
// CHECK: apply
// CHECK: apply
// CHECK-NOT: destroy_value
// CHECK-LABEL: } // end sil function 'testSharedCopy'
sil [ossa] @testSharedCopy : $@convention(thin) <T> (@in T) -> () {
bb0(%arg : @owned $T):
  %copy = copy_value %arg : $T
  %f1 = function_ref @takeGuaranteed : $@convention(thin) <T> (@in_guaranteed T) -> ()
  %call1 = apply %f1<T>(%copy) : $@convention(thin) <T> (@in_guaranteed T) -> ()
  %f2 = function_ref @takeOwned : $@convention(thin) <T> (@in T) -> ()
  %call2 = apply %f2<T>(%copy) : $@convention(thin) <T> (@in T) -> ()
  destroy_value %arg : $T
  %10 = tuple ()
  return %10 : $()
}

// A copy within a borrow scope is not handled by CopyPropagation. An
// earlier pass should have hoisted the copy outside of the borrow
// scope.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testBorrowCopy
// CHECK-TRACE:  Outer copy          [[OUTERCOPY:%.*]] = copy_value %0 : $T
// CHECK-TRACE:  Use of outer copy   destroy_value
// CHECK-TRACE:  Removing   %{{.*}} = copy_value
// CHECK-TRACE:  Removing   destroy_value [[OUTERCOPY]] : $T
// CHECK-TRACE:  Removing   [[OUTERCOPY]] = copy_value %0 : $T
//
// CHECK-LABEL: sil [ossa] @testBorrowCopy : $@convention(thin) <T> (@in T) -> () {
// CHECK-LABEL: bb0(%0 : @owned $T):
// CHECK-NEXT:   begin_borrow %0 : $T
// CHECK-NEXT:   end_borrow
// CHECK-NEXT:   destroy_value %0 : $T
// CHECK-NEXT:   tuple ()
// CHECK-NEXT:   return
// CHECK-LABEL: }
sil [ossa] @testBorrowCopy : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %3 = begin_borrow %0 : $T
  %4 = copy_value %3 : $T
  end_borrow %3 : $T
  destroy_value %4 : $T
  destroy_value %0 : $T
  %17 = tuple ()
  return %17 : $()
}

// CHECK-TRACE-LABEL: *** CopyPropagation: testCopyBorrow
// CHECK-TRACE:  Removing   destroy_value %1 : $T
// CHECK-TRACE:  Removing   %{{.*}} = copy_value %0 : $T
// CHECK-TRACE-NOT: Removing
//
// CHECK-LABEL: sil [ossa] @testCopyBorrow : $@convention(thin) <T> (@in T) -> () {
// CHECK:       bb0(%0 : @owned $T):
// CHECK-NEXT:  %1 = begin_borrow %0 : $T
// CHECK-NEXT:  end_borrow %1 : $T
// CHECK-NEXT:  destroy_value %0 : $T
// CHECK-NEXT:  tuple
// CHECK-NEXT:  return
// CHECK-LABEL: } // end sil function 'testCopyBorrow'
sil [ossa] @testCopyBorrow : $@convention(thin) <T> (@in T) -> () {
bb0(%0 : @owned $T):
  %1 = copy_value %0 : $T
  %2 = begin_borrow %1 : $T
  end_borrow %2 : $T
  destroy_value %1 : $T
  destroy_value %0 : $T
  %17 = tuple ()
  return %17 : $()
}

sil @testThrows : $@convention(thin) <τ_0_0> (τ_0_0) -> (@error Error)

// CHECK-TRACE-LABEL: *** CopyPropagation: testTryApply
//
// CHECK-LABEL: sil [ossa] @testTryApply : $@convention(thin) <T> (@in T) -> @error Error {
// CHECK: bb0(%0 : @owned $T):
// CHECK:   function_ref @testThrows : $@convention(thin) <τ_0_0> (τ_0_0) -> @error Error
// CHECK:   try_apply %{{.*}}<T>(%0) : $@convention(thin) <τ_0_0> (τ_0_0) -> @error Error, normal bb1, error bb2
// CHECK: bb1(%3 : $()):
// CHECK:   destroy_value %0 : $T
// CHECK:   br bb3
// CHECK: bb2(%{{.*}} : @owned $Error):
// CHECK:   destroy_value %0 : $T
// CHECK:   destroy_value %{{.*}} : $Error
// CHECK:   br bb3
// CHECK: bb3:
// CHECK-NOT: destroy
// CHECK:   return
// CHECK-LABEL: } // end sil function 'testTryApply'
sil [ossa] @testTryApply : $@convention(thin) <T> (@in T) -> (@error Error) {
bb0(%0 : @owned $T):
  %1 = copy_value %0 : $T
  destroy_value %0 : $T
  %f = function_ref @testThrows : $@convention(thin) <τ_0_0> (τ_0_0) -> (@error Error)
  try_apply %f<T>(%1) : $@convention(thin) <τ_0_0> (τ_0_0) -> (@error Error), normal bb1, error bb2

bb1(%returnval : $()):
  br bb3

bb2(%error : @owned $Error):
  destroy_value %error : $Error
  br bb3

bb3:
  destroy_value %1 : $T
  %17 = tuple ()
  return %17 : $()
}

// -----------------------------------------------------------------------------
// Test that convert_escape_to_noescape is a PointerEscape

sil @closure : $@convention(thin) <T> (@thick T.Type) -> @owned @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> Bool for <T, T>

sil @takeClosure : $@convention(thin) <T> (@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>) -> (@owned AnyObject, @error Error)

// CHECK-TRACE-LABEL: *** CopyPropagation: testConvertFunction
//
// CHECK-LABEL: sil [ossa] @testConvertFunction : $@convention(thin) <T> (@in_guaranteed T) -> @owned AnyObject {
// CHECK: bb0(%0 : @guaranteed $T):
// CHECK: [[CLOSURE:%.*]] = apply %{{.*}}<T>(%{{.*}}) : $@convention(thin) <τ_0_0> (@thick τ_0_0.Type) -> @owned @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> Bool for <τ_0_0, τ_0_0>
// CHECK: [[CONVERT:%.*]] = convert_function [[CLOSURE]] : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> Bool for <T, T> to $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
// CHECK: [[COPY:%.*]] = copy_value [[CONVERT]] : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
// CHECK: [[NOESCAPE:%.*]] = convert_escape_to_noescape [[COPY]] : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T> to $@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
// CHECK: try_apply %{{.*}}<T>([[NOESCAPE]]) : $@convention(thin) <τ_0_0> (@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <τ_0_0, τ_0_0>) -> (@owned AnyObject, @error Error), normal bb1, error bb2
// CHECK: bb1
// CHECK:   destroy_value [[COPY]] : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
// CHECK:   destroy_value [[CONVERT]] : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
// CHECK:   return
// CHECK: bb2
// CHECK:   destroy_value [[COPY]] : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
// CHECK:   unreachable
// CHECK-LABEL: } // end sil function 'testConvertFunction'
sil [ossa] @testConvertFunction : $@convention(thin) <T> (@in_guaranteed T) -> @owned AnyObject {
bb0(%0 : @guaranteed $T):
  %2 = metatype $@thick T.Type
  %3 = function_ref @closure : $@convention(thin) <τ_0_0> (@thick τ_0_0.Type) -> @owned @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> Bool for <τ_0_0, τ_0_0>
  %4 = apply %3<T>(%2) : $@convention(thin) <τ_0_0> (@thick τ_0_0.Type) -> @owned @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> Bool for <τ_0_0, τ_0_0>
  %5 = convert_function %4 : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> Bool for <T, T> to $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
  %6 = copy_value %5 : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
  %7 = convert_escape_to_noescape %6 : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T> to $@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
  %8 = function_ref @takeClosure : $@convention(thin) <τ_0_0> (@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <τ_0_0, τ_0_0>) -> (@owned AnyObject, @error Error)
  try_apply %8<T>(%7) : $@convention(thin) <τ_0_0> (@noescape @callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <τ_0_0, τ_0_0>) -> (@owned AnyObject, @error Error), normal bb1, error bb2

bb1(%10 : @owned $AnyObject):
  destroy_value %6 : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
  destroy_value %5 : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
  return %10 : $AnyObject

bb2(%14 : @owned $Error):
  destroy_value %6 : $@callee_guaranteed @substituted <τ_0_0, τ_0_1> (@in_guaranteed τ_0_0, @in_guaranteed τ_0_1) -> (Bool, @error Error) for <T, T>
  unreachable
}

// -----------------------------------------------------------------------------
// Test end_apply

struct Struct {
  var st: Int
}

sil @swift_modifyAtWritableKeyPath : $@yield_once @convention(thin) <τ_0_0, τ_0_1> (@inout τ_0_0, @guaranteed WritableKeyPath<τ_0_0, τ_0_1>) -> @yields @inout τ_0_1
sil @modifyInt : $@convention(thin) (@inout Int) -> ()

// CHECK-TRACE-LABEL: *** CopyPropagation: testBeginApply
//
// CHECK-LABEL: sil hidden [ossa] @testBeginApply : $@convention(thin) (@inout Struct) -> () {
// CHECK: begin_apply
// CHECK-NOT: destroy
// CHECK: apply
// CHECK-NOT: destroy
// CHECK: end_apply
// CHECK-NOT: destroy
// CHECK: destroy_value %{{.*}} : $WritableKeyPath<Struct, Int>
// CHECK-NOT: destroy
// CHECK-LABEL: } // end sil function 'testBeginApply'
sil hidden [ossa] @testBeginApply : $@convention(thin) (@inout Struct) -> () {
bb0(%0 : $*Struct):
  %2 = keypath $WritableKeyPath<Struct, Int>, (root $Struct; stored_property #Struct.st : $Int)
  debug_value %2 : $WritableKeyPath<Struct, Int>, let, name "kp"
  %4 = copy_value %2 : $WritableKeyPath<Struct, Int>
  %5 = function_ref @swift_modifyAtWritableKeyPath : $@yield_once @convention(thin) <τ_0_0, τ_0_1> (@inout τ_0_0, @guaranteed WritableKeyPath<τ_0_0, τ_0_1>) -> @yields @inout τ_0_1
  (%6, %7) = begin_apply %5<Struct, Int>(%0, %4) : $@yield_once @convention(thin) <τ_0_0, τ_0_1> (@inout τ_0_0, @guaranteed WritableKeyPath<τ_0_0, τ_0_1>) -> @yields @inout τ_0_1
  %8 = function_ref @modifyInt : $@convention(thin) (@inout Int) -> ()
  %9 = apply %8(%6) : $@convention(thin) (@inout Int) -> ()
  end_apply %7
  destroy_value %4 : $WritableKeyPath<Struct, Int>
  destroy_value %2 : $WritableKeyPath<Struct, Int>
  %13 = tuple ()
  return %13 : $()
}

// FIXME: project_box is currently a PointerEscape, so box live ranges are not canonicalized.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testProjectBox
//
// CHECK-LABEL: sil [ossa] @testProjectBox : $@convention(thin) (@owned B) -> @owned B {
// CHECK: copy_value
// CHECK: destroy_value
// CHECK: destroy_value
// CHECK-LABEL: } // end sil function 'testProjectBox'
sil [ossa] @testProjectBox : $@convention(thin) (@owned B) -> @owned B {
bb0(%0 : @owned $B):
  %box = alloc_box $<τ_0_0> { var τ_0_0 } <B>
  %boxadr = project_box %box : $<τ_0_0> { var τ_0_0 } <B>, 0
  store %0 to [init] %boxadr : $*B
  %load = load [copy] %boxadr : $*B
  %copy = copy_value %box : $<τ_0_0> { var τ_0_0 } <B>
  destroy_value %box : $<τ_0_0> { var τ_0_0 } <B>
  destroy_value %copy : $<τ_0_0> { var τ_0_0 } <B>
  return %load : $B
}

// FIXME: mark_dependence is currently a PointerEscape, so dependent live ranges are not canonicalized.
//
// CHECK-TRACE-LABEL: *** CopyPropagation: testMarkDependence
//
// CHECK-LABEL: sil [ossa] @testMarkDependence : $@convention(thin) (@inout Builtin.Int64, @owned B) -> Builtin.Int64 {
// CHECK: copy_value
// CHECK: destroy_value
// CHECK: destroy_value
// CHECK-LABEL: } // end sil function 'testMarkDependence'
sil [ossa] @testMarkDependence : $@convention(thin) (@inout Builtin.Int64, @owned B) -> Builtin.Int64 {
bb0(%0 : $*Builtin.Int64, %1 : @owned $B):
  %ptr = mark_dependence %0 : $*Builtin.Int64 on %1 : $B
  %val = load [trivial] %ptr : $*Builtin.Int64
  %copy = copy_value %1 : $B
  destroy_value %1 : $B
  destroy_value %copy : $B
  return %val : $Builtin.Int64
}

// CHECK-TRACE-LABEL: *** CopyPropagation: testBitwiseEscape
//
// CHECK-LABEL: sil [ossa] @testBitwiseEscape : $@convention(thin) (@guaranteed C) -> Builtin.RawPointer {
// CHECK-NOT: copy_value
// CHECK-NOT: destroy_value
// CHECK-LABEL: } // end sil function 'testBitwiseEscape'
sil [ossa] @testBitwiseEscape : $@convention(thin) (@guaranteed C) -> Builtin.RawPointer {
bb0(%0 : @guaranteed $C):
  %raw = ref_to_raw_pointer %0 : $C to $Builtin.RawPointer
  %copy = copy_value %0 : $C
  destroy_value %copy : $C
  return %raw : $Builtin.RawPointer
}

// CHECK-TRACE-LABEL: *** CopyPropagation: testInteriorPointer
//
// CHECK-LABEL: sil [ossa] @testInteriorPointer : $@convention(thin) (@guaranteed C) -> Int64 {
// CHECK: bb0(%0 : @guaranteed $C):
// CHECK-NEXT: begin_borrow
// CHECK-NEXT: ref_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: end_borrow
// CHECK-NEXT: return
// CHECK-LABEL: } // end sil function 'testInteriorPointer'
sil [ossa] @testInteriorPointer : $@convention(thin) (@guaranteed C) -> Int64 {
bb0(%0 : @guaranteed $C):
  %copy1 = copy_value %0 : $C
  %borrow = begin_borrow %copy1 : $C
  %adr = ref_element_addr %borrow : $C, #C.a
  %val = load [trivial] %adr : $*Int64
  %copy2 = copy_value %borrow : $C
  end_borrow %borrow : $C
  destroy_value %copy1 : $C
  destroy_value %copy2 : $C
  return %val : $Int64
}

// CHECK-TRACE-LABEL: *** CopyPropagation: testExtract
//
// CHECK-LABEL: sil [ossa] @testExtract : $@convention(thin) (@guaranteed NativeObjectPair) -> @owned Builtin.NativeObject {
// CHECK: bb0(%0 : @guaranteed $NativeObjectPair):
// CHECK-NEXT:  [[B:%.*]] = begin_borrow %0 : $NativeObjectPair
// CHECK-NEXT:  [[E:%.*]] = struct_extract [[B]] : $NativeObjectPair, #NativeObjectPair.obj1
// CHECK-NEXT:  [[C:%.*]] = copy_value [[E]] : $Builtin.NativeObject
// CHECK-NEXT:  end_borrow
// CHECK-NEXT:  return [[C]] : $Builtin.NativeObject
// CHECK-LABEL: } // end sil function 'testExtract'
sil [ossa] @testExtract : $@convention(thin) (@guaranteed NativeObjectPair) -> @owned Builtin.NativeObject {
bb0(%0 : @guaranteed $NativeObjectPair):
  %copy1 = copy_value %0 : $NativeObjectPair
  %borrow = begin_borrow %copy1 : $NativeObjectPair
  %copy2 = copy_value %borrow : $NativeObjectPair
  %val = struct_extract %borrow : $NativeObjectPair, #NativeObjectPair.obj1
  %copy3 = copy_value %val : $Builtin.NativeObject
  end_borrow %borrow : $NativeObjectPair
  %copy4 = copy_value %copy3 : $Builtin.NativeObject
  destroy_value %copy1 : $NativeObjectPair
  destroy_value %copy2 : $NativeObjectPair
  destroy_value %copy3 : $Builtin.NativeObject
  return %copy4 : $Builtin.NativeObject
}

// =============================================================================
// Test extending liveness though overlapping access scopes.
// =============================================================================

class X {}
class Y {}

sil [ossa] @getObject : $@convention(thin) () -> @owned AnyObject

// No overlap (access ignored):
//     def
//     use
//     begin_access
//     end_access
//     destroy
//
// CHECK-LABEL: sil [ossa] @testNoOverlapInLiveBlock : $@convention(thin) () -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK-NOT: copy_value
// CHECK:   store [[DEF]] to [init]
// CHECK:   begin_access
// CHECK:   end_access
// CHECK: bb1:
// CHECK-NOT:   destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testNoOverlapInLiveBlock'
sil [ossa] @testNoOverlapInLiveBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  // end canonical lifetime
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  br bb1

bb1:
  destroy_value %copy : $AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// No overlap (access ignored):
//     def
//     use
//     br...
// bb...
//     begin_access
//     end_access
//     destroy
//
// CHECK-LABEL: sil [ossa] @testNoOverlapInDeadBlock : $@convention(thin) () -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK-NOT: copy_value
// CHECK:   store [[DEF]] to [init] %{{.*}} : $*AnyObject
// CHECK: br bb1
// CHECK: bb1:
// CHECK:   begin_access
// CHECK:   end_access
// CHECK: br bb2
// CHECK: bb2:
// CHECK-NOT: destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testNoOverlapInDeadBlock'
sil [ossa] @testNoOverlapInDeadBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  // end canonical lifetime
  br bb1

bb1:
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  br bb2

bb2:
  destroy_value %copy : $AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Overlapping (must extend pruned liveness):
//
//     %def
//     begin_access // access scope unrelated to def
//     use %def     // pruned liveness ends here
//     end_access
//
// CHECK-LABEL: sil [ossa] @testOverlapInLiveBlock : $@convention(thin) () -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   begin_access
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [init] %{{.*}} : $*AnyObject
// CHECK:   end_access
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK: br bb1
// CHECK: bb1:
// CHECK-NOT: destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testOverlapInLiveBlock'
sil [ossa] @testOverlapInLiveBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  // Branch to avoid reusing the destroy_value
  br bb1

bb1:
  destroy_value %copy : $AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Overlapping (must extend pruned liveness):
//
//     %def
//     begin_access // access scope unrelated to def
//     use %def     // pruned liveness ends here
//     br...
//   bb...
//     end_access
//
// CHECK-LABEL: sil [ossa] @testOverlapInDeadBlock : $@convention(thin) () -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   begin_access
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [init] %{{.*}} : $*AnyObject
// CHECK: br bb1
// CHECK: bb1:
// CHECK:   end_access
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK: br bb2
// CHECK: bb2:
// CHECK-NOT: destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testOverlapInDeadBlock'
sil [ossa] @testOverlapInDeadBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  br bb1

bb1:
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  br bb2

bb2:
  destroy_value %copy : $AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Fully Overlapping (must extend pruned liveness):
//
//     begin_access // access scope unrelated to def
//     %def
//     use %def     // pruned liveness ends here
//     end_access
//
// CHECK-LABEL: sil [ossa] @testFullOverlapInDefBlock : $@convention(thin) () -> () {
// CHECK:   begin_access
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [init] %{{.*}} : $*AnyObject
// CHECK:   end_access
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK: br bb1
// CHECK: bb1:
// CHECK-NOT: destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testFullOverlapInDefBlock'
sil [ossa] @testFullOverlapInDefBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  // Branch to avoid reusing the destroy_value
  br bb1

bb1:
  destroy_value %copy : $AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Fully Overlapping (must extend pruned liveness):
//
//     begin_access // access scope unrelated to def
//     br...
//   bb...
//     %def
//     use %def     // pruned liveness ends here
//     end_access
//
// CHECK-LABEL: sil [ossa] @testFullOverlapBeforeDefBlock : $@convention(thin) () -> () {
// CHECK:   begin_access
// CHECK: br bb1
// CHECK: bb1:
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [init] %{{.*}} : $*AnyObject
// CHECK:   end_access
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK: br bb2
// CHECK: bb2:
// CHECK-NOT: destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testFullOverlapBeforeDefBlock'
sil [ossa] @testFullOverlapBeforeDefBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  br bb1

bb1:
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  // Branch to avoid reusing the destroy_value
  br bb2

bb2:
  destroy_value %copy : $AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Original Overlapping (unnecessarilly extends pruned liveness):
//
// TODO: this copy could be avoided but is probably an unusual case,
// and sinking the destroy outside the access scope might help to
// optimize the access itself.
//
//     %def
//     begin_access // access scope unrelated to def
//     use %def     // pruned liveness ends here
//     destroy %def
//     end_access
//
// CHECK-LABEL: sil [ossa] @testOriginalOverlapInLiveBlock : $@convention(thin) () -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   begin_access
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [init] %{{.*}} : $*AnyObject
// CHECK:   end_access
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK: br bb1
// CHECK-LABEL: } // end sil function 'testOriginalOverlapInLiveBlock'
sil [ossa] @testOriginalOverlapInLiveBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  destroy_value %copy : $AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  br bb1

bb1:
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Original Overlapping (unnecessarilly extends pruned liveness):
//
// TODO: this copy could be avoided but is probably an unusual case,
// and sinking the destroy outside the access scope might help to
// optimize the access itself.
//
//     %def
//     begin_access // access scope unrelated to def
//     use %def     // pruned liveness ends here
//     br bb1
// bb1:
//     destroy %def
//     end_access
//
// CHECK-LABEL: sil [ossa] @testOriginalOverlapInDeadBlock : $@convention(thin) () -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   begin_access
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [init] %{{.*}} : $*AnyObject
// CHECK:   br bb1
// CHECK: bb1:
// CHECK:   end_access
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK-LABEL: } // end sil function 'testOriginalOverlapInDeadBlock'
sil [ossa] @testOriginalOverlapInDeadBlock : $@convention(thin) () -> () {
bb0:
  %box = alloc_box ${ var AnyObject }, var, name "x"
  %adr = project_box %box : ${ var AnyObject }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  %access = begin_access [read] [dynamic] %adr : $*AnyObject
  // use
  store %def to [init] %adr : $*AnyObject
  br bb1

bb1:
  destroy_value %copy : $AnyObject
  %obj = load [copy] %access : $*AnyObject
  end_access %access : $*AnyObject
  destroy_value %obj : $AnyObject
  destroy_value %box : ${ var AnyObject }
  %v = tuple ()
  return %v : $()
}

// Interleaved access (requires iterative lifetime extension):
//
//     %def
//     begin_access X
//     use %def        // Initial pruned lifetime boundary
//     begin_access Y
//     end_access X    // Lifetime boundary after first extension
//     end_access Y    // Lifetime boundary after second extension
//     destroy %def
//
// CHECK-LABEL: sil [ossa] @testInterleavedAccessScope : $@convention(thin) (@inout AnyObject) -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   begin_access {{.*}} : $*X
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [assign] %{{.*}} : $*AnyObject
// CHECK:   begin_access {{.*}} : $*Y
// CHECK:   end_access {{.*}} : $*X
// CHECK:   end_access {{.*}} : $*Y
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK:   br bb1
// CHECK: bb1:
// CHECK-NOT: destroy_value {{.*}} : $AnyObject
// CHECK-LABEL: } // end sil function 'testInterleavedAccessScope'
sil [ossa] @testInterleavedAccessScope : $@convention(thin) (@inout AnyObject) -> () {
bb0(%0 : $*AnyObject):
  %x = alloc_box ${ var X }, var, name "x"
  %xadr = project_box %x : ${ var X }, 0
  %y = alloc_box ${ var Y }, var, name "y"
  %yadr = project_box %y : ${ var Y }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  %accessX = begin_access [read] [dynamic] %xadr : $*X
  // use
  store %def to [assign] %0 : $*AnyObject
  %accessY = begin_access [read] [dynamic] %yadr : $*Y
  // accessX overlaps pruned liveness on the first iteration
  end_access %accessX : $*X
  // accessY only overlaps pruned liveness on the second iteration
  end_access %accessY : $*Y
  br bb1

bb1:
  destroy_value %copy : $AnyObject
  destroy_value %y : ${ var Y }
  destroy_value %x : ${ var X }
  %v = tuple ()
  return %v : $()
}

// Interleaved non-local access (requires iterative lifetime extension):
//
//     %def
//     begin_access X
//     use %def        // Initial pruned lifetime boundary
//     br bb1
//   bb1:
//     begin_access Y
//     br bb2
//   bb2:
//     end_access X    // Lifetime boundary after first extension
//     br bb3
//   bb3:
//     end_access Y    // Lifetime boundary after second extension
//     br bb4
//   bb4:
//     destroy %def
//
// CHECK-LABEL: sil [ossa] @testInterleavedNonLocalAccessScope : $@convention(thin) (@inout AnyObject) -> () {
// CHECK:   [[DEF:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned AnyObject
// CHECK:   begin_access {{.*}} : $*X
// CHECK:   [[COPY:%.*]] = copy_value [[DEF]] : $AnyObject
// CHECK:   store [[COPY]] to [assign] %{{.*}} : $*AnyObject
// CHECK:   br bb1
// CHECK: bb1:
// CHECK:   begin_access {{.*}} : $*Y
// CHECK:   br bb2
// CHECK: bb2:
// CHECK:   end_access {{.*}} : $*X
// CHECK:   br bb3
// CHECK: bb3:
// CHECK:   end_access {{.*}} : $*Y
// CHECK:   destroy_value [[DEF]] : $AnyObject
// CHECK:   br bb4
// CHECK: bb4:
// CHECK-NOT: destroy_value {{.*}} : $AnyObject
// CHECK-LABEL: } // end sil function 'testInterleavedNonLocalAccessScope'
sil [ossa] @testInterleavedNonLocalAccessScope : $@convention(thin) (@inout AnyObject) -> () {
bb0(%0 : $*AnyObject):
  %x = alloc_box ${ var X }, var, name "x"
  %xadr = project_box %x : ${ var X }, 0
  %y = alloc_box ${ var Y }, var, name "y"
  %yadr = project_box %y : ${ var Y }, 0
  %f = function_ref @getObject : $@convention(thin) () -> @owned AnyObject
  // def
  %def = apply %f() : $@convention(thin) () -> @owned AnyObject
  %copy = copy_value %def : $AnyObject
  %accessX = begin_access [read] [dynamic] %xadr : $*X
  // use
  store %def to [assign] %0 : $*AnyObject
  br bb1

bb1:
  %accessY = begin_access [read] [dynamic] %yadr : $*Y
  br bb2

bb2:
  // accessX overlaps pruned liveness on the first iteration
  end_access %accessX : $*X
  br bb3

bb3:
  // accessY only overlaps pruned liveness on the second iteration
  end_access %accessY : $*Y
  br bb4

bb4:
  destroy_value %copy : $AnyObject
  destroy_value %y : ${ var Y }
  destroy_value %x : ${ var X }
  %v = tuple ()
  return %v : $()
}

// =============================================================================
// Test consolidateBorrowScope
// =============================================================================

// Don't consolidate a multi-block borrow scope, but do optimize dead copies.
//
// CHECK-LABEL: sil [ossa] @testMultiBlockBorrow : $@convention(thin) (@guaranteed C) -> () {
// CHECK: bb0(%0 : @guaranteed $C):
// CHECK:   [[BORROW:%.*]] = begin_borrow %0 : $C
// CHECK:   [[CP0:%.*]] = copy_value [[BORROW]] : $C
// CHECK-NOT: copy
// CHECK: cond_br undef, bb1, bb2
// CHECK: bb1:
// CHECK:   [[CP1:%.*]] = copy_value [[BORROW]] : $C
// CHECK:   end_borrow [[BORROW]] : $C
// CHECK-NOT: copy
// CHECK:   apply %{{.*}}([[CP1]]) : $@convention(thin) (@owned C) -> ()
// CHECK: br bb3
// CHECK: bb2:
// CHECK-NOT: copy
// CHECK-NOT: destroy
// CHECK:   br bb3                                          // id: %10
// CHECK: bb3:
// CHECK-NOT: destroy
// CHECK:   apply %1([[CP0]]) : $@convention(thin) (@owned C) -> ()
// CHECK-NOT: destroy
// CHECK-LABEL: } // end sil function 'testMultiBlockBorrow'
sil [ossa] @testMultiBlockBorrow : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  %f = function_ref @takeOwnedC : $@convention(thin) (@owned C) -> ()
  %borrow = begin_borrow %0 : $C
  %copy0a = copy_value %borrow : $C
  %copy0b = copy_value %borrow : $C
  cond_br undef, bb1, bb2
bb1:
  %copy1a = copy_value %borrow : $C
  end_borrow %borrow : $C
  %copy1b = copy_value %copy1a : $C
  %call1 = apply %f(%copy1a) : $@convention(thin) (@owned C) -> ()
  destroy_value %copy1b : $C
  br bb3
bb2:
  end_borrow %borrow : $C
  br bb3
bb3:
  destroy_value %copy0a : $C

  %call2 = apply %f(%copy0b) : $@convention(thin) (@owned C) -> ()
  %result = tuple ()
  return %result : $()
}

// Consolidate a local borrow scope with post-dominating destroy.
//
// CHECK-LABEL: sil [ossa] @testLocalBorrowPostDomDestroy : $@convention(thin) (@owned C) -> () {
// CHECK:        [[OUTERCOPY:%.*]] = copy_value %0 : $C
// CHECK-NEXT:   [[BORROW:%.*]] = begin_borrow %0 : $C
// CHECK-NEXT:   end_borrow [[BORROW]] : $C
// CHECK-NEXT:   cond_br undef, bb1, bb2
// CHECK:      bb1:
// CHECK-NEXT:   [[COPY:%.*]] = copy_value [[OUTERCOPY]] : $C
// CHECK-NEXT:   apply %{{.*}}([[COPY]]) : $@convention(thin) (@owned C) -> ()
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   br bb3
// CHECK:      bb3:
// CHECK-NEXT:   destroy_value [[OUTERCOPY]] : $C
// CHECK-NEXT:   destroy_value %0 : $C
// CHECK-LABEL: } // end sil function 'testLocalBorrowPostDomDestroy'
sil [ossa] @testLocalBorrowPostDomDestroy : $@convention(thin) (@owned C) -> () {
bb0(%0 : @owned $C):
  // force a pointer escape so the outer owned lifetime is not canonicalized.
  %1 = unchecked_ownership_conversion %0 : $C, @owned to @unowned
  %f = function_ref @takeOwnedC : $@convention(thin) (@owned C) -> ()
  %borrow = begin_borrow %0 : $C
  %copy3 = copy_value %borrow : $C
  end_borrow %borrow : $C
  cond_br undef, bb1, bb2
bb1:
  %copy6 = copy_value %copy3 : $C
  %call7 = apply %f(%copy6) : $@convention(thin) (@owned C) -> ()
  br bb3
bb2:
  br bb3
bb3:
  destroy_value %copy3 : $C
  destroy_value %0 : $C
  %result = tuple ()
  return %result : $()
}

// Consolidate a local borrow scope without a post-dominating destroy.
//
// CHECK-LABEL: sil [ossa] @testLocalBorrowNoPostDomDestroy : $@convention(thin) (@owned C) -> () {
// CHECK:        [[OUTERCOPY:%.*]] = copy_value %0 : $C
// CHECK-NEXT:   [[BORROW:%.*]] = begin_borrow %0 : $C
// CHECK-NEXT:   end_borrow [[BORROW]] : $C
// CHECK-NEXT:   cond_br undef, bb1, bb2
// CHECK:      bb1:
// CHECK-NEXT:   apply %{{.*}}([[OUTERCOPY]]) : $@convention(thin) (@guaranteed C) -> ()
// CHECK-NEXT:   apply %{{.*}}([[OUTERCOPY]]) : $@convention(thin) (@owned C) -> ()
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   apply %{{.*}}([[OUTERCOPY]]) : $@convention(thin) (@guaranteed C) -> ()
// CHECK-NEXT:   destroy_value [[OUTERCOPY]] : $C
// CHECK-NEXT:   br bb3
// CHECK:      bb3:
// CHECK-NEXT:   destroy_value %0 : $C
// CHECK-LABEL: } // end sil function 'testLocalBorrowNoPostDomDestroy'
sil [ossa] @testLocalBorrowNoPostDomDestroy : $@convention(thin) (@owned C) -> () {
bb0(%0 : @owned $C):
  // force a pointer escape so the outer owned lifetime is not canonicalized.
  %1 = unchecked_ownership_conversion %0 : $C, @owned to @unowned
  %fowned = function_ref @takeOwnedC : $@convention(thin) (@owned C) -> ()
  %fguaranteed = function_ref @takeGuaranteedC : $@convention(thin) (@guaranteed C) -> ()
  %borrow = begin_borrow %0 : $C
  %copy3 = copy_value %borrow : $C
  end_borrow %borrow : $C
  cond_br undef, bb1, bb2
bb1:
  %call7 = apply %fguaranteed(%copy3) : $@convention(thin) (@guaranteed C) -> ()
  %call8 = apply %fowned(%copy3) : $@convention(thin) (@owned C) -> ()
  br bb3
bb2:
  %call10 = apply %fguaranteed(%copy3) : $@convention(thin) (@guaranteed C) -> ()
  destroy_value %copy3 : $C
  br bb3
bb3:
  destroy_value %0 : $C
  %result = tuple ()
  return %result : $()
}

// CHECK-LABEL: sil [ossa] @testLocalBorrowDoubleConsume : $@convention(thin) (@owned C) -> () {
// CHECK:   [[OUTERCOPY:%.*]] = copy_value %0 : $C
// CHECK-NEXT:  begin_borrow %0 : $C
// CHECK-NEXT:  end_borrow
// CHECK-NEXT:  cond_br undef, bb1, bb2
// CHECK:     bb1:
// CHECK-NEXT:  apply %{{.*}}([[OUTERCOPY]]) : $@convention(thin) (@guaranteed C) -> ()
// CHECK-NEXT:  [[ARGCOPY:%.*]] = copy_value [[OUTERCOPY]] : $C
// CHECK-NEXT:  apply %2([[OUTERCOPY]], [[ARGCOPY:%.*]]) : $@convention(thin) (@owned C, @owned C) -> ()
// CHECK-NEXT:  br bb3
// CHECK:     bb2:
// CHECK-NEXT:  apply %{{.*}}([[OUTERCOPY]]) : $@convention(thin) (@guaranteed C) -> ()
//
// This copy would be eliminated if the outer lifetime were also canonicalized (no unchecked_ownership_conversion)
// CHECK-NEXT:  %13 = copy_value [[OUTERCOPY]] : $C
// CHECK-NEXT:  destroy_value %13 : $C
// CHECK-NEXT:  destroy_value %4 : $C
// CHECK-NEXT:  br bb3
// CHECK: bb3:
// CHECK-NEXT:  destroy_value %0 : $C
// CHECK-LABEL: } // end sil function 'testLocalBorrowDoubleConsume'
sil [ossa] @testLocalBorrowDoubleConsume : $@convention(thin) (@owned C) -> () {
bb0(%0 : @owned $C):
  // force a pointer escape so the outer owned lifetime is not canonicalized.
  %1 = unchecked_ownership_conversion %0 : $C, @owned to @unowned
  %fowned = function_ref @takeOwnedCTwice : $@convention(thin) (@owned C, @owned C) -> ()
  %fguaranteed = function_ref @takeGuaranteedC : $@convention(thin) (@guaranteed C) -> ()
  %borrow = begin_borrow %0 : $C
  %copy3 = copy_value %borrow : $C
  %copy4 = copy_value %borrow : $C
  end_borrow %borrow : $C
  cond_br undef, bb1, bb2
bb1:
  %call7 = apply %fguaranteed(%copy3) : $@convention(thin) (@guaranteed C) -> ()
  %call8 = apply %fowned(%copy3, %copy4) : $@convention(thin) (@owned C, @owned C) -> ()
  br bb3
bb2:
  %call10 = apply %fguaranteed(%copy3) : $@convention(thin) (@guaranteed C) -> ()
  destroy_value %copy3 : $C
  destroy_value %copy4 : $C
  br bb3
bb3:
  destroy_value %0 : $C
  %result = tuple ()
  return %result : $()
}

// Consolidate this local borrowscope even though it has a
// PointerEscape. The escaping value can be assumed not to be used
// outside the borrow scope.
//
// CHECK-LABEL: sil [ossa] @testBorrowEscape : $@convention(thin) (@guaranteed C) -> () {
// CHECK:       [[BORROW:%.*]] = begin_borrow %0 : $C
// CHECK-NOT:   copy_value
// CHECK:       end_borrow [[BORROW]] : $C
// CHECK-NEXT:  cond_br undef, bb1, bb2
// CHECK:     bb1:
// CHECK:       [[COPY:%.*]] = copy_value %0 : $C
// CHECK:       apply %{{.*}}([[COPY]]) : $@convention(thin) (@owned C) -> ()
// CHECK:       br bb3
// CHECK:     bb2:
// CHECK-NEXT:  br bb3
// CHECK:     bb3:
// CHECK-NOT:   destroy
// CHECK-LABEL: } // end sil function 'testBorrowEscape'
sil [ossa] @testBorrowEscape : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  %borrow = begin_borrow %0 : $C
  // force a pointer escape so the borrow is not canonicalized.
  %1 = unchecked_ownership_conversion %borrow : $C, @guaranteed to @unowned
  %copy3 = copy_value %borrow : $C
  end_borrow %borrow : $C
  cond_br undef, bb1, bb2
bb1:
  %f = function_ref @takeOwnedC : $@convention(thin) (@owned C) -> ()
  %call7 = apply %f(%copy3) : $@convention(thin) (@owned C) -> ()
  br bb3
bb2:
  destroy_value %copy3 : $C
  br bb3
bb3:
  %result = tuple ()
  return %result : $()
}

// A sub-borrow begins within the outer borrow scope but extends
// beyond the end of the outer scope. Treat it like an outer use.
//
// CHECK-LABEL: sil [ossa] @testInterleavedBorrow : $@convention(thin) () -> @owned C {
// CHECK:        [[ALLOC:%.*]] = alloc_ref $C
// CHECK-NEXT:   [[B1:%.*]] = begin_borrow [[ALLOC]]
// CHECK-NEXT:   [[B2:%.*]] = begin_borrow [[ALLOC]]
// CHECK-NEXT:   end_borrow [[B1]] : $C
// CHECK-NEXT:   apply %0([[B2]]) : $@convention(thin) (@guaranteed C) -> ()
// CHECK-NEXT:   end_borrow [[B2]] : $C
// CHECK-NEXT:   return [[ALLOC]] : $C
// CHECK-LABEL: } // end sil function 'testInterleavedBorrow'
sil [ossa] @testInterleavedBorrow : $@convention(thin) () -> @owned C {
bb0:
  %f = function_ref @takeGuaranteedC : $@convention(thin) (@guaranteed C) -> ()
  %0 = alloc_ref $C
  %1 = begin_borrow %0 : $C
  %2 = copy_value %1 : $C
  %3 = begin_borrow %2 : $C
  end_borrow %1 : $C
  apply %f(%3) : $@convention(thin) (@guaranteed C) -> ()
  end_borrow %3 : $C
  destroy_value %2 : $C
  return %0 : $C
}

// A sub-borrow begins within the outer borrow scope but extends
// beyond the end of the outer scope into different blocks. Treat it
// like an outer use.
//
// CHECK-LABEL: sil [ossa] @testInterleavedBorrowCrossBlock : $@convention(thin) () -> @owned C {
// CHECK:        [[ALLOC:%.*]] = alloc_ref $C
// CHECK-NEXT:   [[B1:%.*]] = begin_borrow [[ALLOC]]
// CHECK-NEXT:   [[B2:%.*]] = begin_borrow [[ALLOC]]
// CHECK-NEXT:   end_borrow [[B1]] : $C
// CHECK-NEXT:   cond_br undef, bb1, bb2
// CHECK:      bb1:
// CHECK:        apply %{{.*}}([[B2]]) : $@convention(thin) (@guaranteed C) -> ()
// CHECK-NEXT:   end_borrow [[B2]] : $C
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   end_borrow [[B2]] : $C
// CHECK-NEXT:   br bb3
// CHECK:      bb3:
// CHECK-NEXT:   return [[ALLOC]] : $C
// CHECK-LABEL: } // end sil function 'testInterleavedBorrowCrossBlock'
sil [ossa] @testInterleavedBorrowCrossBlock : $@convention(thin) () -> @owned C {
bb0:
  %0 = alloc_ref $C
  %1 = begin_borrow %0 : $C
  %2 = copy_value %1 : $C
  %3 = begin_borrow %2 : $C
  end_borrow %1 : $C
  cond_br undef, bb1, bb2
bb1:
  %f = function_ref @takeGuaranteedC : $@convention(thin) (@guaranteed C) -> ()
  apply %f(%3) : $@convention(thin) (@guaranteed C) -> ()
  end_borrow %3 : $C
  br bb3
bb2:
  end_borrow %3 : $C
  br bb3
bb3:
  destroy_value %2 : $C
  return %0 : $C
}

// =============================================================================
// Test reborrows
// =============================================================================

// Extend the lifetime of an owned value through a nested borrow scope
// with cross-block reborrows. Its lifetime must be extended past the
// end_borrow of the phi.
//
// TODO: CanonicalizeOSSA currently bails out on reborrows.
//
// CHECK-LABEL: sil [ossa] @testSubReborrowExtension : $@convention(thin) () -> () {
// CHECK: bb0:
// CHECK:   [[ALLOC:%.*]] = alloc_ref $C
// CHECK:   [[CP:%.*]] = copy_value %0 : $C
// CHECK:   [[BORROW:%.*]] = begin_borrow %0 : $C
// CHECK:   cond_br undef, bb1, bb2
// CHECK: bb1:
// CHECK:   br bb3([[CP]] : $C, [[BORROW]] : $C)
// CHECK: bb2:
// CHECK:   br bb3([[CP]] : $C, [[BORROW]] : $C)
// CHECK: bb3([[OWNEDPHI:%.*]] : @owned $C, [[BORROWPHI:%.*]] @guaranteed $C
// CHECK:   end_borrow [[BORROWPHI]]
// CHECK:   destroy_value [[OWNEDPHI]] : $C
// CHECK:   destroy_value %0 : $C
// CHECK-LABEL: } // end sil function 'testSubReborrowExtension'
sil [ossa] @testSubReborrowExtension : $@convention(thin) () -> () {
bb0:
  %alloc = alloc_ref $C
  %copy = copy_value %alloc : $C
  %borrow = begin_borrow %alloc : $C
  cond_br undef, bb1, bb2
bb1:
  br bb3(%copy : $C, %borrow: $C)
bb2:
  br bb3(%copy : $C, %borrow: $C)
bb3(%phi : @owned $C, %borrowphi : @guaranteed $C):
  end_borrow %borrowphi : $C
  destroy_value %phi : $C
  destroy_value %alloc : $C
  %99 = tuple ()
  return %99 : $()
}

// Test a cross-block reborrow and a live nested copy of the reborrow:
//   def: borrow
//   use: phi reborrow (in the same block as the borrow)
//   copy reborrowed phi
//   end reborrow
//   copy outside borrow scope.
//
// consolidateBorrow only processes the SSA borrow scope, not the
// extended borrow scope, and it does not process the borrow scope
// introduced by the phi. Therefore, it should leave the in-scope copy
// alone-- it will be treated like the definition of a separate OSSA
// lifetime. The inner copy's lifetime will be canonicalized, removing
// outercopy.
//
// CHECK-LABEL: sil [ossa] @testLiveCopyAfterReborrow : $@convention(thin) () -> () {
// CHECK: [[ALLOC:%.*]] = alloc_ref $C
// CHECK: bb3([[BORROWPHI:%.*]] : @guaranteed $C):
// CHECK: [[COPY:%.*]] = copy_value [[BORROWPHI]]
// CHECK: end_borrow [[BORROWPHI]] : $C
// CHECK-NOT: copy_value
// CHECK-NOT: destroy_value
// CHECK: apply
// CHECK: destroy_value [[COPY]]
// CHECK: destroy_value [[ALLOC]] : $C
// CHECK-LABEL: } // end sil function 'testLiveCopyAfterReborrow'
sil [ossa] @testLiveCopyAfterReborrow : $@convention(thin) () -> () {
bb0:
  %alloc = alloc_ref $C
  cond_br undef, bb1, bb2
bb1:
  %borrow1 = begin_borrow %alloc : $C
  br bb3(%borrow1: $C)
bb2:
  %borrow2 = begin_borrow %alloc : $C
  br bb3(%borrow2: $C)
bb3(%borrowphi : @guaranteed $C):
  %innercopy = copy_value %borrowphi : $C
  end_borrow %borrowphi : $C
  %outercopy = copy_value %innercopy : $C
  destroy_value %innercopy : $C
  %f = function_ref @takeGuaranteedC : $@convention(thin) (@guaranteed C) -> ()
  apply %f(%outercopy) : $@convention(thin) (@guaranteed C) -> ()
  destroy_value %outercopy : $C
  destroy_value %alloc : $C
  %99 = tuple ()
  return %99 : $()
}

// Test a cross-block reborrow and a dead nested copy of the reborrow:
//   def: borrow
//   use: phi reborrow (in the same block as the borrow)
//   copy reborrowed phi
//   end reborrow
//   use of copied reborrow outside borrow scope.
//
// consolidateBorrow only processes the SSA borrow scope, not the
// extended borrow scope, and it does not process the borrow scope
// introduced by the phi. Therefore, it should leave the in-scope copy alone--
// it will be treated like the definition of a separate OSSA lifetime.
// The inner copy's lifetime will be canonicalized, removing
// outercopy.
//
// CHECK-LABEL: sil [ossa] @testDeadCopyAfterReborrow : $@convention(thin) () -> () {
// CHECK: [[ALLOC:%.*]] = alloc_ref $C
// CHECK: bb3([[BORROWPHI:%.*]] : @guaranteed $C):
// CHECK-NOT: copy_value
// CHECK: end_borrow [[BORROWPHI]] : $C
// CHECK-NOT: copy_value
// CHECK: destroy_value [[ALLOC]] : $C
// CHECK-LABEL: } // end sil function 'testDeadCopyAfterReborrow'
sil [ossa] @testDeadCopyAfterReborrow : $@convention(thin) () -> () {
bb0:
  %alloc = alloc_ref $C
  cond_br undef, bb1, bb2
bb1:
  %borrow1 = begin_borrow %alloc : $C
  br bb3(%borrow1: $C)
bb2:
  %borrow2 = begin_borrow %alloc : $C
  br bb3(%borrow2: $C)
bb3(%borrowphi : @guaranteed $C):
  %innercopy = copy_value %borrowphi : $C
  end_borrow %borrowphi : $C
  %outercopy = copy_value %innercopy : $C
  destroy_value %innercopy : $C
  destroy_value %outercopy : $C
  destroy_value %alloc : $C
  %99 = tuple ()
  return %99 : $()
}

// Test a reborrow with a nested borrow with an outside use
//   def: borrowphi
//   nested borrow -- consolidated borrow scope
//   inner copy -- removed when rewriting nested borrow
//   end nested borrow
//   middle copy -- when consolidating borrow scope,
//                  its operand is replace with a copy of borrowphi
//                  then removeed when borrowphi's copy is canonicalized
//   end borrowphi
//   outer copy -- removeed when borrowphi's copy is canonicalized
//
// CHECK-LABEL: sil [ossa] @testNestedReborrowOutsideUse : $@convention(thin) () -> () {
// CHECK:        [[ALLOC:%.*]] = alloc_ref $C
// CHECK:      bb3([[BORROWPHI:%.*]] : @guaranteed $C):
// CHECK-NEXT:   [[COPY:%.*]] = copy_value [[BORROWPHI]] : $C
// CHECK-NEXT:   begin_borrow [[BORROWPHI]] : $C
// CHECK-NEXT:   end_borrow
// CHECK-NEXT:   end_borrow
// CHECK-NEXT:   destroy_value [[COPY]] : $C
// CHECK-NEXT:   destroy_value [[ALLOC]] : $C
// CHECK-LABEL: } // end sil function 'testNestedReborrowOutsideUse'
sil [ossa] @testNestedReborrowOutsideUse : $@convention(thin) () -> () {
bb0:
  %alloc = alloc_ref $C
  cond_br undef, bb1, bb2
bb1:
  %borrow1 = begin_borrow %alloc : $C
  br bb3(%borrow1: $C)
bb2:
  %borrow2 = begin_borrow %alloc : $C
  br bb3(%borrow2: $C)
bb3(%borrowphi : @guaranteed $C):
  %nestedborrow = begin_borrow %borrowphi : $C
  %innercopy = copy_value %nestedborrow : $C
  end_borrow %nestedborrow : $C
  %middlecopy = copy_value %innercopy : $C
  end_borrow %borrowphi : $C
  %outercopy = copy_value %middlecopy : $C
  destroy_value %innercopy : $C
  destroy_value %middlecopy : $C
  destroy_value %outercopy : $C
  destroy_value %alloc : $C
  %99 = tuple ()
  return %99 : $()
}

// Test a reborrow of an owned-and-copied def that does not dominate
// the extended borrow scope.
//
// CHECK-LABEL: sil [ossa] @testOwnedReborrow : $@convention(thin) (@owned C) -> () {
// CHECK: bb1:
// CHECK:   destroy_value %0 : $C
// CHECK:   [[CALL:%.*]] = apply %{{.*}}() : $@convention(thin) () -> @owned C
// CHECK:   [[COPY1:%.*]] = copy_value [[CALL]] : $C
// CHECK:   begin_borrow [[COPY1]] : $C
// CHECK:   destroy_value [[CALL]] : $C
// CHECK:   br bb3(%{{.*}} : $C, [[COPY1]] : $C)
// CHECK: bb2:
// CHECK:   begin_borrow %0 : $C
// CHECK:   br bb3(%{{.*}} : $C, %0 : $C)
// CHECK: bb3(%{{.*}} : @guaranteed $C, [[COPYPHI:%.*]] : @owned $C):
// CHECK:   end_borrow
// CHECK:   destroy_value [[COPYPHI]] : $C
// CHECK-LABEL: } // end sil function 'testOwnedReborrow'
sil [ossa] @testOwnedReborrow : $@convention(thin) (@owned C) -> () {
bb0(%0 : @owned $C):
  cond_br undef, bb1, bb2
bb1:
  destroy_value %0 : $C
  %f = function_ref @getOwnedC : $@convention(thin) () -> (@owned C)
  %owned1 = apply %f() : $@convention(thin) () -> (@owned C)
  %copy1 = copy_value %owned1 : $C
  %borrow1 = begin_borrow %copy1 : $C
  destroy_value %owned1 : $C
  br bb3(%borrow1 : $C, %copy1 : $C)
bb2:
  %borrow2 = begin_borrow %0 : $C
  br bb3(%borrow2 : $C, %0 : $C)
bb3(%borrow3 : @guaranteed $C, %copy3 : @owned $C):
  end_borrow %borrow3 : $C
  destroy_value %copy3 : $C
  %result = tuple ()
  return %result : $()
}
