<FunctionDecl><Attribute>// RUN: rm -rf %t
// RUN: %swift-syntax-test -input-source-filename %s -parse-gen > %t
// RUN: diff -u %s %t
// RUN: %swift-syntax-test -input-source-filename %s -parse-gen -print-node-kind > %t.withkinds
// RUN: diff -u %S/Outputs/round_trip_parse_gen.swift.withkinds %t.withkinds
// RUN: %swift-syntax-test -input-source-filename %s -eof > %t
// RUN: diff -u %s %t
// RUN: %swift-syntax-test -serialize-raw-tree -input-source-filename %s > %t.dump
// RUN: %swift-syntax-test -deserialize-raw-tree -input-source-filename %t.dump -output-filename %t
// RUN: diff -u %s %t

// Note: RUN lines copied from test/Syntax/round_trip_parse_gen.swift.

@differentiable(<DifferentiableAttributeArguments><DifferentiableAttributeFuncSpecifier>jvp: <FunctionDeclName>foo<DeclNameArguments>(<DeclNameArgument>_:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></FunctionDeclName></DifferentiableAttributeFuncSpecifier></DifferentiableAttributeArguments>)</Attribute>
func bar<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>_: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier>Float </SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@differentiable(<DifferentiableAttributeArguments><DifferentiableAttributeFuncSpecifier>jvp: <FunctionDeclName>foo<DeclNameArguments>(<DeclNameArgument>_:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>) </DeclNameArguments></FunctionDeclName></DifferentiableAttributeFuncSpecifier><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier>T </SimpleTypeIdentifier>: <SimpleTypeIdentifier>FloatingPoint</SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause></DifferentiableAttributeArguments>)</Attribute>
func bar<GenericParameterClause><<GenericParameter>T : <SimpleTypeIdentifier>Numeric</SimpleTypeIdentifier></GenericParameter>></GenericParameterClause><FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>T</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>_: <SimpleTypeIdentifier>T</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier>T </SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@differentiable(<DifferentiableAttributeArguments><DifferentiationParamsClause>wrt: <DifferentiationParam>x</DifferentiationParam></DifferentiationParamsClause>, <DifferentiableAttributeFuncSpecifier>jvp: <FunctionDeclName>foo<DeclNameArguments>(<DeclNameArgument>_:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></FunctionDeclName></DifferentiableAttributeFuncSpecifier></DifferentiableAttributeArguments>)</Attribute>
func bar<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>_: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier>Float </SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@differentiable(<DifferentiableAttributeArguments><DifferentiationParamsClause>wrt: <DifferentiationParams>(<DifferentiationParam>self, </DifferentiationParam><DifferentiationParam>x, </DifferentiationParam><DifferentiationParam>y</DifferentiationParam>)</DifferentiationParams></DifferentiationParamsClause>, <DifferentiableAttributeFuncSpecifier>jvp: <FunctionDeclName>foo<DeclNameArguments>(<DeclNameArgument>_:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></FunctionDeclName></DifferentiableAttributeFuncSpecifier></DifferentiableAttributeArguments>)</Attribute>
func bar<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier>Float </SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@differentiable(<DifferentiableAttributeArguments><DifferentiationParamsClause>wrt: <DifferentiationParams>(<DifferentiationParam>self, </DifferentiationParam><DifferentiationParam>x, </DifferentiationParam><DifferentiationParam>y</DifferentiationParam>)</DifferentiationParams></DifferentiationParamsClause>, <DifferentiableAttributeFuncSpecifier>jvp: <FunctionDeclName>bar</FunctionDeclName>, </DifferentiableAttributeFuncSpecifier><DifferentiableAttributeFuncSpecifier>vjp: <FunctionDeclName>foo<DeclNameArguments>(<DeclNameArgument>_:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>) </DeclNameArguments></FunctionDeclName></DifferentiableAttributeFuncSpecifier><GenericWhereClause>where <GenericRequirement><ConformanceRequirement><SimpleTypeIdentifier>T </SimpleTypeIdentifier>: <SimpleTypeIdentifier>FloatingPoint</SimpleTypeIdentifier></ConformanceRequirement></GenericRequirement></GenericWhereClause></DifferentiableAttributeArguments>)</Attribute>
func bar<GenericParameterClause><<GenericParameter>T : <SimpleTypeIdentifier>Numeric</SimpleTypeIdentifier></GenericParameter>></GenericParameterClause><FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>T</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y: <SimpleTypeIdentifier>T</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <SimpleTypeIdentifier>T </SimpleTypeIdentifier></ReturnClause></FunctionSignature><CodeBlock>{ <ReturnStmt>return <IntegerLiteralExpr>1 </IntegerLiteralExpr></ReturnStmt>}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@derivative(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName>-</QualifiedDeclName></DerivativeRegistrationAttributeArguments>)</Attribute>
func negateDerivative<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>)</ParameterClause><ReturnClause>
    -> <TupleType>(<TupleTypeElement>value: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement>pullback: <FunctionType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) -> <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionType></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><PrefixOperatorExpr>-<IdentifierExpr>x</IdentifierExpr></PrefixOperatorExpr>, </TupleExprElement><TupleExprElement><ClosureExpr>{ <ClosureSignature><ClosureParam>v </ClosureParam>in </ClosureSignature><PrefixOperatorExpr>-<IdentifierExpr>v </IdentifierExpr></PrefixOperatorExpr>}</ClosureExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@derivative(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName>baz<DeclNameArguments>(<DeclNameArgument>label:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></QualifiedDeclName>, <DifferentiationParamsClause>wrt: <DifferentiationParams>(<DifferentiationParam>x</DifferentiationParam>)</DifferentiationParams></DifferentiationParamsClause></DerivativeRegistrationAttributeArguments>)</Attribute>
func bazDerivative<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>)</ParameterClause><ReturnClause>
    -> <TupleType>(<TupleTypeElement>value: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement>pullback: <FunctionType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) -> <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionType></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>x</IdentifierExpr>, </TupleExprElement><TupleExprElement><ClosureExpr>{ <ClosureSignature><ClosureParam>v </ClosureParam>in </ClosureSignature><IdentifierExpr>v </IdentifierExpr>}</ClosureExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@transpose(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName>-</QualifiedDeclName></DerivativeRegistrationAttributeArguments>)</Attribute>
func negateDerivative<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>)</ParameterClause><ReturnClause>
    -> <TupleType>(<TupleTypeElement>value: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement>pullback: <FunctionType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) -> <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionType></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><PrefixOperatorExpr>-<IdentifierExpr>x</IdentifierExpr></PrefixOperatorExpr>, </TupleExprElement><TupleExprElement><ClosureExpr>{ <ClosureSignature><ClosureParam>v </ClosureParam>in </ClosureSignature><PrefixOperatorExpr>-<IdentifierExpr>v </IdentifierExpr></PrefixOperatorExpr>}</ClosureExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@derivative(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName>baz<DeclNameArguments>(<DeclNameArgument>label:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></QualifiedDeclName>, <DifferentiationParamsClause>wrt: <DifferentiationParams>(<DifferentiationParam>x</DifferentiationParam>)</DifferentiationParams></DifferentiationParamsClause></DerivativeRegistrationAttributeArguments>)</Attribute>
func bazDerivative<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>)</ParameterClause><ReturnClause>
    -> <TupleType>(<TupleTypeElement>value: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement>pullback: <FunctionType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) -> <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionType></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>x</IdentifierExpr>, </TupleExprElement><TupleExprElement><ClosureExpr>{ <ClosureSignature><ClosureParam>v </ClosureParam>in </ClosureSignature><IdentifierExpr>v </IdentifierExpr>}</ClosureExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@derivative(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName><MemberTypeIdentifier><MemberTypeIdentifier><SimpleTypeIdentifier>A<GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier>T</SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SimpleTypeIdentifier>.B<GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier>U</SimpleTypeIdentifier>, </GenericArgument><GenericArgument><SimpleTypeIdentifier>V</SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></MemberTypeIdentifier>.C</MemberTypeIdentifier>.foo<DeclNameArguments>(<DeclNameArgument>label:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></QualifiedDeclName>, <DifferentiationParamsClause>wrt: <DifferentiationParam>x</DifferentiationParam></DifferentiationParamsClause></DerivativeRegistrationAttributeArguments>)</Attribute>
func qualifiedDerivative<FunctionSignature><ParameterClause>(<FunctionParameter>_ x: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </FunctionParameter><FunctionParameter>y: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>)</ParameterClause><ReturnClause>
    -> <TupleType>(<TupleTypeElement>value: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement>pullback: <FunctionType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) -> <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionType></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>x</IdentifierExpr>, </TupleExprElement><TupleExprElement><ClosureExpr>{ <ClosureSignature><ClosureParam>v </ClosureParam>in </ClosureSignature><IdentifierExpr>v </IdentifierExpr>}</ClosureExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@transpose(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName>+</QualifiedDeclName></DerivativeRegistrationAttributeArguments>)</Attribute>
func addTranspose<FunctionSignature><ParameterClause>(<FunctionParameter>_ v: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <TupleType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>v</IdentifierExpr>, </TupleExprElement><TupleExprElement><IdentifierExpr>v</IdentifierExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@transpose(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName>-</QualifiedDeclName>, <DifferentiationParamsClause>wrt: <DifferentiationParams>(<DifferentiationParam>0, </DifferentiationParam><DifferentiationParam>1</DifferentiationParam>)</DifferentiationParams></DifferentiationParamsClause></DerivativeRegistrationAttributeArguments>)</Attribute>
func subtractTranspose<FunctionSignature><ParameterClause>(<FunctionParameter>_ v: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <TupleType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>v</IdentifierExpr>, </TupleExprElement><TupleExprElement><PrefixOperatorExpr>-<IdentifierExpr>v</IdentifierExpr></PrefixOperatorExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@transpose(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName><SimpleTypeIdentifier>Float</SimpleTypeIdentifier>.-</QualifiedDeclName>, <DifferentiationParamsClause>wrt: <DifferentiationParams>(<DifferentiationParam>0, </DifferentiationParam><DifferentiationParam>1</DifferentiationParam>)</DifferentiationParams></DifferentiationParamsClause></DerivativeRegistrationAttributeArguments>)</Attribute>
func subtractTranspose<FunctionSignature><ParameterClause>(<FunctionParameter>_ v: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <TupleType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>v</IdentifierExpr>, </TupleExprElement><TupleExprElement><PrefixOperatorExpr>-<IdentifierExpr>v</IdentifierExpr></PrefixOperatorExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl><FunctionDecl><Attribute>

@derivative(<DerivativeRegistrationAttributeArguments>of: <QualifiedDeclName><MemberTypeIdentifier><MemberTypeIdentifier><SimpleTypeIdentifier>A<GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier>T</SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></SimpleTypeIdentifier>.B<GenericArgumentClause><<GenericArgument><SimpleTypeIdentifier>U</SimpleTypeIdentifier>, </GenericArgument><GenericArgument><SimpleTypeIdentifier>V</SimpleTypeIdentifier></GenericArgument>></GenericArgumentClause></MemberTypeIdentifier>.C</MemberTypeIdentifier>.foo<DeclNameArguments>(<DeclNameArgument>label:</DeclNameArgument><DeclNameArgument>_:</DeclNameArgument>)</DeclNameArguments></QualifiedDeclName>, <DifferentiationParamsClause>wrt: <DifferentiationParam>0</DifferentiationParam></DifferentiationParamsClause></DerivativeRegistrationAttributeArguments>)</Attribute>
func qualifiedTranspose<FunctionSignature><ParameterClause>(<FunctionParameter>_ v: <SimpleTypeIdentifier>Float</SimpleTypeIdentifier></FunctionParameter>) </ParameterClause><ReturnClause>-> <TupleType>(<TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier>, </TupleTypeElement><TupleTypeElement><SimpleTypeIdentifier>Float</SimpleTypeIdentifier></TupleTypeElement>) </TupleType></ReturnClause></FunctionSignature><CodeBlock>{<ReturnStmt>
  return <TupleExpr>(<TupleExprElement><IdentifierExpr>v</IdentifierExpr>, </TupleExprElement><TupleExprElement><PrefixOperatorExpr>-<IdentifierExpr>v</IdentifierExpr></PrefixOperatorExpr></TupleExprElement>)</TupleExpr></ReturnStmt>
}</CodeBlock></FunctionDecl>
